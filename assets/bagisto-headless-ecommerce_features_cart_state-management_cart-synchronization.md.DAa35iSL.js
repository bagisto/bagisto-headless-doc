import{j as e,c as a,b as t,ah as i}from"./chunks/framework.Br27zpCu.js";const k=JSON.parse('{"title":"Cart Synchronization","description":"","frontmatter":{},"headers":[],"relativePath":"bagisto-headless-ecommerce/features/cart/state-management/cart-synchronization.md","filePath":"bagisto-headless-ecommerce/features/cart/state-management/cart-synchronization.md","lastUpdated":1769687094000}'),n={name:"bagisto-headless-ecommerce/features/cart/state-management/cart-synchronization.md"};function r(h,s,o,l,p,c){return t(),a("div",null,[...s[0]||(s[0]=[i(`<h1 id="cart-synchronization" tabindex="-1">Cart Synchronization <a class="header-anchor" href="#cart-synchronization" aria-label="Permalink to &quot;Cart Synchronization&quot;">â€‹</a></h1><p>This guide explains how the Bagisto Headless storefront ensures that the client-side cart state remains synchronized with the backend Bagisto GraphQL API.</p><h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">â€‹</a></h2><p>Cart synchronization is the process of keeping the local Redux store in lockstep with the server-side data. This is critical in e-commerce to ensure that prices, quantities, and totals shown to the user are always accurate. Synchronization occurs during three primary events: immediate mutation responses, initial page rehydration, and guest-to-customer cart merging.</p><h2 id="_1-reactive-synchronization-via-mutations" tabindex="-1">1. Reactive Synchronization via Mutations <a class="header-anchor" href="#_1-reactive-synchronization-via-mutations" aria-label="Permalink to &quot;1. Reactive Synchronization via Mutations&quot;">â€‹</a></h2><p>Every time a user modifies their cart (adding an item, changing quantity, or removing an item), a GraphQL mutation is executed. The Bagisto API returns the complete updated cart object in the mutation response.</p><h3 id="implementation-in-custom-hooks" tabindex="-1">Implementation in Custom Hooks <a class="header-anchor" href="#implementation-in-custom-hooks" aria-label="Permalink to &quot;Implementation in Custom Hooks&quot;">â€‹</a></h3><p>Our custom hooks, such as <code>useAddProduct</code>, catch these responses and immediately dispatch them to the Redux store.</p><p><strong>File:</strong> <code>src/utils/hooks/useAddToCart.ts</code></p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mutateAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useMutation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  onSuccess</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">res</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> responseData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> res?.data?.createAddProductInCart?.addProductInCart;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (responseData?.success) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // SYNCHRONIZATION: Update local store with fresh server data</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      dispatch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(responseData));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h2 id="_2-guest-to-customer-cart-merging" tabindex="-1">2. Guest to Customer Cart Merging <a class="header-anchor" href="#_2-guest-to-customer-cart-merging" aria-label="Permalink to &quot;2. Guest to Customer Cart Merging&quot;">â€‹</a></h2><p>When a guest user logs in, they may already have items in their guest cart. To preserve these items, the storefront performs a &quot;Merge Cart&quot; operation.</p><h3 id="merge-logic" tabindex="-1">Merge Logic <a class="header-anchor" href="#merge-logic" aria-label="Permalink to &quot;Merge Logic&quot;">â€‹</a></h3><p>The <code>useMergeCart</code> hook sends the guest&#39;s <code>cartId</code> and the authenticated user&#39;s <code>token</code> to the server. The server merges the items and returns the final consolidated cart, which is then used to update the Redux store.</p><p><strong>File:</strong> <code>src/utils/hooks/useMergeCart.ts</code></p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onSuccess</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">response</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> responseData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> response?.data?.createMergeCart?.mergeCart;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (responseData) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Update local state with the merged cart results</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    dispatch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(responseData));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Update persisted guest_cart_id if it changed</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    setCookie</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;guest_cart_id&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(responseData.id));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="_3-initial-load-synchronization" tabindex="-1">3. Initial Load Synchronization <a class="header-anchor" href="#_3-initial-load-synchronization" aria-label="Permalink to &quot;3. Initial Load Synchronization&quot;">â€‹</a></h2><p>When a user first visits the site or refreshes the page, the storefront must &quot;rehydrate&quot; the Redux store from the server using the persisted session token.</p><ul><li><strong>Check Persistence:</strong> The application retrieves the <code>GUEST_CART_TOKEN</code> from cookies.</li><li><strong>Fetch Latest State:</strong> A query is executed to fetch the current cart details from the Bagisto API using this token.</li><li><strong>Dispatch to Store:</strong> The retrieved data is dispatched to the Redux store, ensuring the <code>Navbar</code> cart counter and <code>CartSidebar</code> are accurate from the moment the page becomes interactive.</li></ul><h2 id="_4-why-sync-matters" tabindex="-1">4. Why Sync Matters <a class="header-anchor" href="#_4-why-sync-matters" aria-label="Permalink to &quot;4. Why Sync Matters&quot;">â€‹</a></h2><p>Synchronizing after every write operation provides several benefits:</p><ul><li><strong>Price Accuracy:</strong> Correctly reflects discounts, taxes, and shipping rates calculated by the Bagisto core.</li><li><strong>Inventory Validation:</strong> Ensures that the quantities requested are actually available in the backend.</li><li><strong>Seamless Experience:</strong> Users can transition between devices or guest/logged-in states without losing their shopping progress.</li></ul><h2 id="summary" tabindex="-1">Summary <a class="header-anchor" href="#summary" aria-label="Permalink to &quot;Summary&quot;">â€‹</a></h2><ul><li><strong>Mutation-Driven:</strong> Immediate updates following any cart modification.</li><li><strong>Consolidated Merging:</strong> Handles the transition from guest to customer sessions.</li><li><strong>Server-Side Truth:</strong> The Redux store always reflects the latest state from the Bagisto GraphQL API.</li><li><strong>Persistent Connectivity:</strong> Uses session tokens in cookies to maintain sync across page reloads.</li></ul><h2 id="next-steps" tabindex="-1">Next Steps <a class="header-anchor" href="#next-steps" aria-label="Permalink to &quot;Next Steps&quot;">â€‹</a></h2><ul><li>ðŸ’¾ <a href="/bagisto-headless-ecommerce/features/cart/state-management/cart-persistence">Cart Persistence</a> - Understanding how tokens are stored.</li><li>ðŸ§± <a href="/bagisto-headless-ecommerce/features/cart/state-management/actions-reducers">Cart Actions and Reducers</a> - How the Redux store processes synchronized data.</li></ul>`,26)])])}const g=e(n,[["render",r]]);export{k as __pageData,g as default};
